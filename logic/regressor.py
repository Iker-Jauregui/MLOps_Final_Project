"""
Track revenue prediction library

This module provides functions for predicting revenue generated by music tracks
based on the number of reproductions (streams/plays) using a trained ONNX model.
"""

import json
import numpy as np
import onnxruntime as ort
from pathlib import Path

# Load the production ONNX model and metadata at module level
MODEL_PATH = Path(__file__).parent.parent / "production" / "model" / "best_rf.onnx"
METADATA_PATH = Path(__file__).parent.parent / "production" / "model" / "categorical_metadata.json"

# Load ONNX model
ort_session = ort.InferenceSession(str(MODEL_PATH))
print(f"ONNX model loaded from {MODEL_PATH}")

# Load categorical metadata
with open(METADATA_PATH, 'r') as f:
    categorical_metadata = json.load(f)
print(f"Categorical metadata loaded from {METADATA_PATH}")

# Get expected input shape
input_meta = ort_session.get_inputs()[0]
print(f"Model expects input: {input_meta.name}, shape: {input_meta.shape}")

# Build encoding mappings from JSON metadata
# Each categorical feature will have a mapping: {category_string: index}
ENCODERS = {}

for feature_name, feature_info in categorical_metadata.items():
    categories = feature_info['categories']
    
    # Add 'UNKNOWN' as index 0 if not already present
    if 'UNKNOWN' not in categories:
        categories = ['UNKNOWN'] + categories
    
    # Create mapping from category to index
    category_to_idx = {cat: idx for idx, cat in enumerate(categories)}
    ENCODERS[feature_name] = category_to_idx
    
    print(f"Loaded encoder for '{feature_name}': {len(categories)} categories (including UNKNOWN)")

# Default values (UNKNOWN = 0 for all)
DEFAULT_ENCODED_VALUES = {
    'ISRC': 0,      # UNKNOWN
    'continent': 0, # UNKNOWN (will override with Europe if not provided)
    'zone': 0       # UNKNOWN
}


def _encode_categorical(value, feature_name):
    """
    Encode a categorical value using the loaded metadata.
    
    Parameters
    ----------
    value : str or None
        The category value to encode
    feature_name : str
        Name of the feature ('ISRC', 'continent', or 'zone')
    
    Returns
    -------
    int
        Encoded integer value
    """
    if value is None or value == '':
        return DEFAULT_ENCODED_VALUES[feature_name]
    
    # Get the encoder for this feature
    encoder = ENCODERS.get(feature_name)
    if encoder is None:
        raise ValueError(f"No encoder found for feature '{feature_name}'")
    
    # Look up the category in the encoder
    encoded_value = encoder.get(value)
    
    # If category not found, use UNKNOWN (index 0)
    if encoded_value is None:
        print(f"Warning: '{value}' not found in '{feature_name}' categories, using UNKNOWN")
        return 0
    
    return encoded_value


def predict(quantity, isrc=None, continent=None, zone=None):
    """
    Predict track revenue using a trained Random Forest model (ONNX).
    
    This function uses a production-ready ONNX model to predict revenue
    based on the number of reproductions and optional categorical features.
    
    Parameters
    ----------
    quantity : float or array-like
        The number of reproductions/streams/plays for the track(s).
        Must be non-negative.
    isrc : str, optional
        International Standard Recording Code (ISRC) of the track.
        If None or empty, defaults to "UNKNOWN".
    continent : str, optional
        Continent where the track is being played.
        Valid values: "Africa", "Asia", "Europe", "LATAM", "North America", "Oceania".
        If None or empty, defaults to "Europe".
    zone : str, optional
        Geographic zone within the continent.
        If None or empty, defaults to "UNKNOWN".
    
    Returns
    -------
    float or np.ndarray
        Predicted revenue in euros.
    
    Notes
    -----
    **Model Architecture:**
    - Random Forest trained with Optuna optimization
    - Input features (in order): ISRC, continent, zone, quantity
    - Output: predicted revenue in euros
    
    **Categorical encoding:**
    All categorical features are encoded using mappings loaded from metadata JSON.
    Unknown categories automatically map to index 0 (UNKNOWN).
    
    **Default values:**
    - ISRC: "UNKNOWN" (encoded as 0)
    - continent: "Europe" (encoded based on metadata)
    - zone: "UNKNOWN" (encoded as 0)
    
    Examples
    --------
    >>> predict(1000)
    2.05  # Prediction with defaults (Europe, UNKNOWN ISRC/zone)
    
    >>> predict(1000, isrc="USRC17607839", continent="North America", zone="USA")
    2.15  # Prediction with specific categorical values
    
    >>> import numpy as np
    >>> predict(np.array([1000, 5000, 10000]))
    array([  2.05,  10.12,  19.87])
    
    Raises
    ------
    ValueError
        If quantity contains negative values.
    """
    # Convert to numpy array for uniform handling
    quantity_array = np.asarray(quantity, dtype=np.float32)

    # Validate that all quantities are non-negative
    if np.any(quantity_array < 0):
        raise ValueError("'quantity' must be non-negative")

    # Apply default for continent if not provided
    if continent is None or continent == '':
        continent = "Europe"
    
    # Encode categorical features
    isrc_encoded = _encode_categorical(isrc, 'ISRC')
    continent_encoded = _encode_categorical(continent, 'continent')
    zone_encoded = _encode_categorical(zone, 'zone')

    # Prepare input with all 4 features: [ISRC, continent, zone, quantity]
    if quantity_array.ndim == 0:
        # Scalar input
        input_data = np.array([[
            float(isrc_encoded),
            float(continent_encoded),
            float(zone_encoded),
            float(quantity_array)
        ]], dtype=np.float32)
    else:
        # Array input - broadcast categorical features to all samples
        n_samples = len(quantity_array)
        input_data = np.column_stack([
            np.full(n_samples, isrc_encoded, dtype=np.float32),
            np.full(n_samples, continent_encoded, dtype=np.float32),
            np.full(n_samples, zone_encoded, dtype=np.float32),
            quantity_array.flatten()
        ])
    
    # Get input name from ONNX model
    input_name = ort_session.get_inputs()[0].name
    
    # Run inference
    predictions = ort_session.run(None, {input_name: input_data})[0]
    
    # Return scalar if input was scalar, otherwise return array
    if np.asarray(quantity).ndim == 0:
        return float(predictions.item())
    else:
        return predictions.flatten()
