"""
Track revenue prediction library

This module provides functions for predicting revenue generated by music tracks
based on the number of reproductions (streams/plays) using a trained ONNX model.
"""

import numpy as np
import onnxruntime as ort
from pathlib import Path

# Load the production ONNX model at module level (loads once on import)
MODEL_PATH = Path(__file__).parent.parent / "production" / "model" / "best_rf.onnx"
ort_session = ort.InferenceSession(str(MODEL_PATH))

print(f"ONNX model loaded from {MODEL_PATH}")


def predict(quantity):
    """
    Predict track revenue using a trained Random Forest model (ONNX).
    
    This function uses a production-ready ONNX model to predict revenue
    based on the number of reproductions.
    
    Parameters
    ----------
    quantity : float or array-like
        The number of reproductions/streams/plays for the track(s).
        Must be non-negative.
    
    Returns
    -------
    float or np.ndarray
        Predicted revenue in euros.
    
    Notes
    -----
    **Model Architecture:**
    - Random Forest trained with Optuna optimization
    - Input: number of reproductions (streams)
    - Output: predicted revenue in euros
    
    **Input shape:** (n_samples, 1)
    **Data type:** float32
    
    Examples
    --------
    >>> predict(1000)
    2.05  # Example output from ONNX model
    
    >>> predict(500000)
    987.3  # Model prediction
    
    >>> import numpy as np
    >>> predict(np.array([1000, 5000, 10000]))
    array([  2.05,  10.12,  19.87])  # Model predictions
    
    Raises
    ------
    ValueError
        If quantity contains negative values.
    """
    # Convert to numpy array for uniform handling
    quantity_array = np.asarray(quantity, dtype=np.float32)

    # Validate that all quantities are non-negative
    if np.any(quantity_array < 0):
        raise ValueError("'quantity' must be non-negative")

    # Reshape for model input: (n_samples, 1)
    if quantity_array.ndim == 0:
        # Scalar input
        input_data = quantity_array.reshape(1, 1)
    else:
        # Array input
        input_data = quantity_array.reshape(-1, 1)
    
    # Get input name from ONNX model
    input_name = ort_session.get_inputs()[0].name
    
    # Run inference
    predictions = ort_session.run(None, {input_name: input_data})[0]
    
    # Return scalar if input was scalar, otherwise return array
    if np.asarray(quantity).ndim == 0:
        return float(predictions[0])
    else:
        return predictions.flatten()