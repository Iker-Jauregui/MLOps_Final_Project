"""
Track revenue prediction library

This module provides functions for predicting revenue generated by music tracks
based on the number of reproductions (streams/plays) using a trained ONNX model.
"""

import numpy as np
import onnxruntime as ort
from pathlib import Path

# Load the production ONNX model at module level (loads once on import)
MODEL_PATH = Path(__file__).parent.parent / "production" / "model" / "best_rf.onnx"
ort_session = ort.InferenceSession(str(MODEL_PATH))

print(f"ONNX model loaded from {MODEL_PATH}")

# Get expected input shape
input_meta = ort_session.get_inputs()[0]
print(f"Model expects input: {input_meta.name}, shape: {input_meta.shape}")

# Default values for categorical features
DEFAULT_ISRC = 0       # UNKNOWN
DEFAULT_CONTINENT = 3  # Europe
DEFAULT_ZONE = 0       # UNKNOWN


def predict(quantity, isrc=None, continent=None, zone=None):
    """
    Predict track revenue using a trained Random Forest model (ONNX).
    
    This function uses a production-ready ONNX model to predict revenue
    based on the number of reproductions and optional categorical features.
    
    Parameters
    ----------
    quantity : float or array-like
        The number of reproductions/streams/plays for the track(s).
        Must be non-negative.
    isrc : int, optional
        ISRC code (encoded as integer). If None, defaults to 0 (UNKNOWN).
    continent : int, optional
        Continent code (encoded as integer). If None, defaults to 3 (Europe).
    zone : int, optional
        Zone code (encoded as integer). If None, defaults to 0 (UNKNOWN).
    
    Returns
    -------
    float or np.ndarray
        Predicted revenue in euros.
    
    Notes
    -----
    **Model Architecture:**
    - Random Forest trained with Optuna optimization
    - Input features (in order): ISRC, continent, zone, quantity
    - Output: predicted revenue in euros
    
    **Default feature values:**
    - ISRC: 0 (UNKNOWN)
    - continent: 3 (Europe)
    - zone: 0 (UNKNOWN)
    
    **Feature encoding:**
    All categorical features use label encoding where index 0 represents UNKNOWN.
    
    Examples
    --------
    >>> predict(1000)
    2.05  # Prediction with default categorical features
    
    >>> predict(1000, isrc=42, continent=3, zone=5)
    2.15  # Prediction with specific categorical values
    
    >>> import numpy as np
    >>> predict(np.array([1000, 5000, 10000]))
    array([  2.05,  10.12,  19.87])
    
    Raises
    ------
    ValueError
        If quantity contains negative values.
    """
    # Convert to numpy array for uniform handling
    quantity_array = np.asarray(quantity, dtype=np.float32)

    # Validate that all quantities are non-negative
    if np.any(quantity_array < 0):
        raise ValueError("'quantity' must be non-negative")

    # Use defaults if not provided
    isrc = DEFAULT_ISRC if isrc is None else isrc
    continent = DEFAULT_CONTINENT if continent is None else continent
    zone = DEFAULT_ZONE if zone is None else zone

    # Prepare input with all 4 features: [ISRC, continent, zone, quantity]
    if quantity_array.ndim == 0:
        # Scalar input
        input_data = np.array([[
            float(isrc),
            float(continent),
            float(zone),
            float(quantity_array)
        ]], dtype=np.float32)
    else:
        # Array input - broadcast categorical features to all samples
        n_samples = len(quantity_array)
        input_data = np.column_stack([
            np.full(n_samples, isrc, dtype=np.float32),
            np.full(n_samples, continent, dtype=np.float32),
            np.full(n_samples, zone, dtype=np.float32),
            quantity_array.flatten()
        ])
    
    # Get input name from ONNX model
    input_name = ort_session.get_inputs()[0].name
    
    # Run inference
    predictions = ort_session.run(None, {input_name: input_data})[0]
    
    # Return scalar if input was scalar, otherwise return array
    if np.asarray(quantity).ndim == 0:
        return float(predictions.item())
    else:
        return predictions.flatten()